"""
Task Management App based on Stephen Covey's 7 Habits of highly effectively people

- 2024-11-02
    - V6
        - add note
        - before adding a task or note, query by user-key to prevent duplicates

- v5
    - verify user functionality
        - add_user() was defined twice by mistake, causing unexpected behavior: user not added
        - populate sample tasks in tests/sample-tasks-20.sql

- v4
    - ask Claude to add user login page

- v3
    - merge v1 and v2, incorporated streamlit-aggrid component by me

- v2
    - generated by DeepSeek 

- v1
    - generated by Claude 3.5 Sonnet

"""

import streamlit as st

import re
from glob import glob
import sqlite3
import hashlib
from datetime import datetime, date, timedelta
import pandas as pd
from st_aggrid import (
    AgGrid, GridOptionsBuilder, GridUpdateMode, DataReturnMode, JsCode
)

st.set_page_config(
    page_title='Habits-7 Tasks',
    layout="wide",
    initial_sidebar_state="expanded",
)

def init_session_state():
    st.session_state['logged_in'] = False
    st.session_state['user_id'] = None
    st.session_state['username'] = None
    st.session_state['is_admin'] = False

# init session_state
if "username" not in st.session_state:
    init_session_state()

# constants
# =========================

# pages
PAGE_EDIT_USER = "Edit User"
PAGE_MANAGE_NOTE = "Manage Note"
PAGE_MANAGE_TASK = "Manage Task"
PAGE_7_HABITS_TASK = "7-Habits-Task View"
PAGE_HOME = "Home"

PAGE_SIZE, GRID_HEIGHT = 5, 200

# database
DB_FILE = "habits7.sqlite"

# LOV
LIST_TASK_GROUP = ['Work', 'Personal']
LIST_Y_N = ["Y", "N"]
LIST_TASK_STATUS = ["ToDo", "Doing", "Done"]
LIST_PROGRESS = ["0%", "25%", "50%", "75%", "100%"]
LIST_TASK_CATEGORY = ["", "learning", "research", "project", "fun"]
LIST_NOTE_TYPE = ["", "learning", "research", "project", "journal"]

LABEL_REQUIRED = "(*)"

# table names
TABLE_H7_USER = "habits7_user"
TABLE_H7_TASK = "habits7_task"
TABLE_H7_NOTE = "habits7_note"

# DDL for creating tables
CREATE_TABLE_DDL = {
    TABLE_H7_USER: f'''
    CREATE TABLE IF NOT EXISTS {TABLE_H7_USER} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        email TEXT NOT NULL UNIQUE,
        password TEXT NOT NULL,
        username TEXT NOT NULL,
        is_admin INTEGER DEFAULT 0 CHECK(is_admin IN (0, 1)),
        is_active INTEGER DEFAULT 1 CHECK(is_active IN (0, 1)),
        profile TEXT,
        note TEXT,
        created_by TEXT,
        created_at TEXT,
        updated_by TEXT,
        updated_at TEXT
    )
    ''',

    TABLE_H7_TASK: f'''
    CREATE TABLE IF NOT EXISTS {TABLE_H7_TASK} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        task_name TEXT NOT NULL,
        description TEXT,
        task_type TEXT DEFAULT '' CHECK(task_type IN ('', 'learning', 'research', 'project', 'fun')),
        task_group TEXT DEFAULT 'Personal' CHECK(task_group IN ('','Work', 'Personal')),
        is_urgent TEXT DEFAULT 'N' CHECK(is_urgent IN ('Y', 'N')),
        is_important TEXT DEFAULT 'N' CHECK(is_important IN ('Y', 'N')),
        status TEXT DEFAULT '' CHECK(status IN ('', 'ToDo', 'Doing', 'Done')),
        pct_completed TEXT DEFAULT '0%' CHECK(pct_completed IN ('0%', '25%', '50%', '75%', '100%')),
        due_date TEXT,
        note TEXT,
        created_by TEXT,
        created_at TEXT,
        updated_by TEXT,
        updated_at TEXT
    )
    ''',

    TABLE_H7_NOTE: f'''
    CREATE TABLE IF NOT EXISTS {TABLE_H7_NOTE} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        note_name TEXT NOT NULL,
        url text,
        note_type TEXT DEFAULT '' CHECK(note_type IN ('', 'learning', 'research', 'project', 'journal')),
        note TEXT,
        tags TEXT,
        created_by TEXT,
        created_at TEXT,
        updated_by TEXT,
        updated_at TEXT
    )
    ''',

}

USER_KEY_COLS = {
    TABLE_H7_USER: ["email", "username"],
    TABLE_H7_TASK: ["task_name", "task_type"],
    TABLE_H7_NOTE: ["note_name", "url", "note_type"],
}

# Aggrid options
# how to set column width
# https://stackoverflow.com/questions/72624323/how-to-set-a-max-column-length-for-streamlit-aggrid
_GRID_OPTIONS = {
    "paginationPageSize": 10,
    "grid_height": 350,
    "return_mode_value": DataReturnMode.__members__["FILTERED"],
    "update_mode_value": GridUpdateMode.__members__["MODEL_CHANGED"],
    "fit_columns_on_grid_load": True,
    "selection_mode": "single",  #  "multiple",  # 
    "allow_unsafe_jscode": True,
    "groupSelectsChildren": True,
    "groupSelectsFiltered": True,
    "enable_pagination": True,
}



class DBConn(object):
    def __init__(self, db_file=DB_FILE):
        self.conn = sqlite3.connect(db_file)

    def __enter__(self):
        return self.conn

    def __exit__(self, type, value, traceback):
        self.conn.commit()
        self.conn.close()

def run_sql(sql_stmt, DEBUG_SQL=True):
    """ 
    Helper to execute SQL without parametrized columns.
    Otherwise, create cursor and call execute() API.

        con = sqlite3.connect(DB_FILE, check_same_thread=False)
        cur = con.cursor()
        cur.execute(sql_stmt)
        con.commit()

    Returns:
        df - pandas dataframe
    """

    if DEBUG_SQL:
        print(sql_stmt)

    with DBConn() as conn:
        if sql_stmt.lower().strip().startswith("select") or \
            sql_stmt.lower().strip().startswith("with"):
            return pd.read_sql_query(sql_stmt, conn)
            # read_sql_query is more efficient than read_sql

        c = conn.cursor()

        x = [s.strip() for s in sql_stmt.split(";") if s.strip()]
        if len(x) < 1: 
            return None 
        if len(x) > 1:
            c.executescript(sql_stmt)
            conn.commit()
            return None 
        
        df = None
        c.execute(sql_stmt)
        try:
            data = c.fetchall()
            if c.description is not None:
                columns = [description[0] for description in c.description]
                df = pd.DataFrame(data, columns=columns)
            conn.commit()
        except Exception as e:
            print(f"[ERROR-DB] run_sql():\n {str(e)}")

        return df



def ddl_to_label_dict(ddl, reserved_words=['if', 'not', 'exists', 'table', 'create', 'primary', 'constraint', 'foreign', 'references', 'DEFAULT']):
    # Convert reserved words to lowercase for case-insensitive comparison
    reserved_words = [word.strip().lower() for word in reserved_words if word.strip()]
    
    # Extract column definitions from DDL
    # This regex now captures column names that might include underscores
    column_defs = re.findall(r'(\w+(?:_\w+)*)\s+[\w()]+', ddl)
    
    # Function to convert snake_case to Camel Case
    def to_camel_case(string):
        return ' '.join(word.capitalize() for word in string.split('_'))
    
    # Create dictionary with column names as keys and camel-cased labels as values
    col_label_dict = {col: to_camel_case(col) for col in column_defs if col.lower() not in reserved_words}
    if "url" in col_label_dict:  # special
        col_label_dict.update({"url": "URL"})  
    return col_label_dict

COL_LABELS = {k: ddl_to_label_dict(v) for k,v in CREATE_TABLE_DDL.items() }


def create_tables():
    if check_table_state(TABLE_H7_USER):
        create_user_table()
    if check_table_state(TABLE_H7_TASK):
        create_task_table()
    if check_table_state(TABLE_H7_NOTE):
        create_note_table()

# Function to create user table
def create_user_table():
    sql_stmt = CREATE_TABLE_DDL[TABLE_H7_USER]
    run_sql(sql_stmt)

# Function to create task table
def create_task_table():
    sql_stmt = CREATE_TABLE_DDL[TABLE_H7_TASK]
    run_sql(sql_stmt)

# Function to create note table
def create_note_table():
    sql_stmt = CREATE_TABLE_DDL[TABLE_H7_NOTE]
    run_sql(sql_stmt)

def _display_df_grid(df, 
        selection_mode="single",  # "multiple", 
        fit_columns_on_grid_load=_GRID_OPTIONS["fit_columns_on_grid_load"],
        # min_column_width=_GRID_OPTIONS["min_column_width"],
        page_size=_GRID_OPTIONS["paginationPageSize"],
        grid_height=_GRID_OPTIONS["grid_height"],
        clickable_columns=[],
        editable_columns=[],
        colored_columns={},
        key_name="df"
    ):
    """show input df in a grid and return selected row

    URL link stopped working - see fix reported here
    https://discuss.streamlit.io/t/streamlit-aggrid-version-creating-an-aggrid-with-columns-with-embedded-urls/39640/2
    """

    gb = GridOptionsBuilder.from_dataframe(df)
    gb.configure_selection(selection_mode,
            use_checkbox=True,
            groupSelectsChildren=_GRID_OPTIONS["groupSelectsChildren"], 
            groupSelectsFiltered=_GRID_OPTIONS["groupSelectsFiltered"]
        )
    gb.configure_pagination(paginationAutoPageSize=True, 
        paginationPageSize=page_size)
    
    gb.configure_columns(editable_columns, editable=True)

    # color column
    for k,v in colored_columns.items():
        gb.configure_column(k, cellStyle=v)

    if clickable_columns:       # config clickable columns
        cell_renderer_url =  JsCode("""
            class UrlCellRenderer {
                init(params) {
                    this.eGui = document.createElement('a');
                    this.eGui.innerText = params.value;
                    this.eGui.setAttribute('href', params.value);
                    this.eGui.setAttribute('style', "text-decoration:none");
                    this.eGui.setAttribute('target', "_blank");
                }
                getGui() {
                    return this.eGui;
                }
            }
        """)

        for col_name in clickable_columns:
            gb.configure_column(col_name, cellRenderer=cell_renderer_url)


    gb.configure_grid_options(domLayout='normal')
    grid_response = AgGrid(
        df, 
        gridOptions=gb.build(),
        data_return_mode=_GRID_OPTIONS["return_mode_value"],
        update_mode=_GRID_OPTIONS["update_mode_value"],
        height=grid_height, 
        fit_columns_on_grid_load=fit_columns_on_grid_load,
        allow_unsafe_jscode=True, #Set it to True to allow jsfunction to be injected
        key=key_name
    )
 
    return grid_response




def handle_task_form(df, username, key_name, page_size=PAGE_SIZE, grid_height=GRID_HEIGHT):
    # display task list
    grid_resp = _display_df_grid(df, page_size=page_size, grid_height=grid_height, key_name=key_name)
    selected_rows = grid_resp['selected_rows']

    # streamlit-aggrid==1.0.5
    selected_row = None if selected_rows is None or len(selected_rows) < 1 else selected_rows.to_dict(orient='records')[0]
    # display task form
    if selected_row is None:
        v_id = v_task_name = v_description = v_note = ""
        v_due_date = date.today() + timedelta(days=5) # .strftime("%Y/%m/%d")
        v_is_urgent = v_is_important = "N"
        v_task_group = "Personal"
        v_status = "ToDo"
        v_pct_completed = "0%"
        v_task_type = ""
        v_created_by = v_updated_by = username
        v_created_at = v_updated_at = date.today()
    else:
        v_id = selected_row.get("id") 
        v_task_name = selected_row.get("task_name")
        v_description = selected_row.get("description")
        v_note = selected_row.get("note")
        v_due_date = datetime.strptime(selected_row.get("due_date"), "%Y-%m-%d")
        v_is_urgent = selected_row.get("is_urgent")
        v_is_important = selected_row.get("is_important")
        v_task_group = selected_row.get("task_group")
        v_status = selected_row.get("status")
        v_pct_completed = selected_row.get("pct_completed")
        v_task_type = selected_row.get("task_type")
        v_created_by = selected_row.get("created_by")
        v_updated_by = selected_row.get("updated_by")
        v_created_at = datetime.strptime(selected_row.get("created_at"), "%Y-%m-%d")
        v_updated_at = datetime.strptime(selected_row.get("updated_at"), "%Y-%m-%d")

    col1, col2, col3, col4 = st.columns([2,2,2,2])
    with col1:
        task_name = st.text_input(COL_LABELS[TABLE_H7_TASK]['task_name'] + LABEL_REQUIRED, value=v_task_name)
        description = st.text_area(COL_LABELS[TABLE_H7_TASK]['description'] + LABEL_REQUIRED,  value=v_description)
        task_type = st.selectbox(COL_LABELS[TABLE_H7_TASK]['task_type'] + LABEL_REQUIRED, LIST_TASK_CATEGORY, index=LIST_TASK_CATEGORY.index(v_task_type))

    with col2:
        is_urgent = st.selectbox(COL_LABELS[TABLE_H7_TASK]['is_urgent'], LIST_Y_N, index=LIST_Y_N.index(v_is_urgent))
        is_important = st.selectbox(COL_LABELS[TABLE_H7_TASK]['is_important'], LIST_Y_N, index=LIST_Y_N.index(v_is_important))
        task_group = st.selectbox(COL_LABELS[TABLE_H7_TASK]['task_group'], LIST_TASK_GROUP, index=LIST_TASK_GROUP.index(v_task_group))
        status = st.selectbox(COL_LABELS[TABLE_H7_TASK]['status'], LIST_TASK_STATUS, index=LIST_TASK_STATUS.index(v_status))

    with col3:
        due_date = st.date_input(COL_LABELS[TABLE_H7_TASK]['due_date'],  value=v_due_date)
        pct_completed = st.selectbox(COL_LABELS[TABLE_H7_TASK]['pct_completed'], LIST_PROGRESS, index=LIST_PROGRESS.index(v_pct_completed))
        note = st.text_area(COL_LABELS[TABLE_H7_TASK]['note'],  value=v_note)

    with col4:
        id = st.text_input(COL_LABELS[TABLE_H7_TASK]['id'],  value=v_id, disabled=True)
        # created_by = st.text_input(COL_LABELS[TABLE_H7_TASK]['created_by'],  value=v_created_by)
        created_at = st.date_input(COL_LABELS[TABLE_H7_TASK]['created_at'],  value=v_created_at)
        updated_by = st.text_input(COL_LABELS[TABLE_H7_TASK]['updated_by'],  value=v_updated_by)
        updated_at = st.date_input(COL_LABELS[TABLE_H7_TASK]['updated_at'],  value=v_updated_at)

    if selected_row is None or not v_id: 
        c_1, _, _, _ = st.columns([2,2,2,2])
        with c_1:
            btn_add = st.button("Add Task")

        if btn_add:
            msg = add_task(task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, username, created_at, username, updated_at)
            if "Record added" in msg:
                st.success(msg)
            elif "Record already exists" in msg:
                st.warning(msg)
            else:
                st.error(msg)

    else:
        delete_flag = False
        c_1, _, _, c_2 = st.columns([2,2,2,2])
        with c_1:
            btn = st.button("Update Task")
        with c_2:
            delete_flag = st.checkbox("Delete?", value=False)

        if btn:
            if delete_flag:
                delete_task_by_id(v_id, username)
                st.success(f"Task Deleted: {v_id}")
            else:
                edit_task_by_id(task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, updated_by, updated_at, 
                    v_id, username)
                st.success(f"Task Updated: {v_id}")


# Function to check if the user is the first user (super-user)
def is_first_user():
    sql_stmt = f"SELECT COUNT(*) FROM {TABLE_H7_USER}"
    df = run_sql(sql_stmt)
    if df is not None and not df.empty:
        count = df.iloc[0,0]
        return count == 0
    else:
        raise Exception(f"Table missing: {TABLE_H7_USER}")

def check_table_state(table_name):
    table_not_found = True
    try:
        sql_stmt = f"SELECT COUNT(*) FROM {table_name}"
        df = run_sql(sql_stmt)
        table_not_found = False
    except Exception as e:
        st.error(str(e))

    return table_not_found
    
def check_database_state():
    st.write("[DEBUG] Checking database state")
    try:
        sql_stmt = f"SELECT COUNT(*) FROM {TABLE_H7_USER}"
        df = run_sql(sql_stmt)
        user_count = 0
        if df is not None and not df.empty:
            user_count = df.iloc[0,0]
            st.write(f"[DEBUG] Total users in database: {user_count}")

        if user_count > 0:
            sql_stmt = f"SELECT * FROM {TABLE_H7_USER}"
            df2 = run_sql(sql_stmt)
            st.dataframe(df2)
        else:
            st.write("[DEBUG] No users in database")

    except Exception as e:
        st.write(f"[DEBUG] Error checking database state: {str(e)}")


# Modified add_user function
def add_user(email, password, username, is_admin=0, is_active=1, profile="", note=""):
    # query if record exists
    table_name = TABLE_H7_USER
    key_data = dict(table_name=table_name, email=email, username=username)
    id = query_user_keys(key_data)
    if id:
        msg = f"""Record already exists:\n
            id={id}, email='{email}', username='{username}'       
        """
        return msg

    try:
        hashed_password = hash_password(password)
        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if is_first_user():
            is_admin = 1

        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
            INSERT INTO {table_name} (email, password, username, is_admin, is_active, profile, note, created_by, created_at, updated_by, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (email, hashed_password, username, is_admin, is_active, profile, note, email, now, email, now))
        msg = f"Record added: email='{email}', username='{username}'"
    except Exception as e:
        msg = f"[DB-ERROR] {str(e)}"

    return msg

# Function to get all users
def query_all_users():
    sql_stmt = f"SELECT id, email, username, is_admin, is_active, profile, note FROM {TABLE_H7_USER} order by email"
    df = run_sql(sql_stmt)
    return df


# Function to update user
def update_user(username, email, is_admin, is_active, profile, note):
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    try:
        with DBConn() as conn:
            c = conn.cursor()        
            c.execute(f'''
            UPDATE {TABLE_H7_USER}
            SET email=?, is_admin=?, is_active=?, profile=?, note=?, updated_at=?
            WHERE username=?
            ''', (email, is_admin, is_active, profile, note, now, username))
    except Exception as e:
        print(f"[DB-ERROR] {str(e)}")        

# Function to get user by id
def get_user_by_id(username):
    with DBConn() as conn:
        c = conn.cursor()      
        c.execute(f"SELECT * FROM {TABLE_H7_USER} WHERE username = ?", (username,))
        return c.fetchone()

# New function for the Edit User page
def edit_user_page(username, is_admin):
    st.subheader(PAGE_EDIT_USER)
    user = get_user_by_id(username)
    if user:
        c1, c2,c3 = st.columns([4,4,2])
        with c1:
            email = st.text_input("Email", value=user[1])
            profile = st.text_area("Profile", value=user[6] or "")

        with c2:
            username = st.text_input("Username", value=user[3])
            note = st.text_area("Note", value=user[7] or "")            

        with c3:
            if is_admin:
                is_admin_flag = st.checkbox("Is Admin", value=bool(user[4]))
                is_active = st.checkbox("Is Active", value=bool(user[5]))
            else:
                is_admin_flag = user[4]
                is_active = user[5]

        if st.button("Update User"):
            update_user(username, email, int(is_admin_flag), int(is_active), profile, note)
            st.success("User updated successfully")
            st.rerun()

# New function for the Add User page (admin only)
def new_user_page():
    st.subheader("New User")
    col_name = 'email'
    email = st.text_input(COL_LABELS[TABLE_H7_USER][col_name])
    col_name = 'username'
    username = st.text_input(COL_LABELS[TABLE_H7_USER][col_name])
    col_name = 'password'
    password = st.text_input(COL_LABELS[TABLE_H7_USER][col_name], type="password")
    confirm_password = st.text_input(f"Confirm {COL_LABELS[TABLE_H7_USER][col_name]}", type="password")
    col_name = 'is_admin'
    is_admin = st.checkbox(COL_LABELS[TABLE_H7_USER][col_name])
    col_name = 'is_active'
    is_active = st.checkbox(COL_LABELS[TABLE_H7_USER][col_name], value=True)
    col_name = 'profile'
    profile = st.text_area(COL_LABELS[TABLE_H7_USER][col_name])
    col_name = 'note'
    note = st.text_area(COL_LABELS[TABLE_H7_USER][col_name])

    if st.button("Add User"):
        if password != confirm_password:
            st.error("Passwords do not match")
        elif email_exists(email):
            st.error("Email already exists")
        else:
            add_user(email, password, username, int(is_admin), int(is_active), profile, note)
            st.success("User added successfully")

# New function for the Manage Users page (admin only)
def manage_users_page():
    st.subheader("Manage Users")
    df = query_all_users()
    grid_resp = _display_df_grid(df, key_name=f"{TABLE_H7_USER}_grid")

    selected_rows = grid_resp['selected_rows']
    if selected_rows is not None and not selected_rows.empty:
        selected_user = selected_rows.iloc[0]
        st.subheader(f"Edit User: {selected_user['username']}")
        c1, c2 = st.columns(2)
        with c1:
            col_name = 'email'
            email = st.text_input(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name])
            col_name = 'username'
            username = st.text_input(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name])
            col_name = 'profile'
            profile = st.text_area(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name])

        with c2:
            col_name = 'id'
            user_id = st.text_input(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name], disabled=True)
            col_name = 'is_admin'
            is_admin = st.checkbox(COL_LABELS[TABLE_H7_USER][col_name], value=bool(selected_user[col_name]))
            col_name = 'is_active'
            is_active = st.checkbox(COL_LABELS[TABLE_H7_USER][col_name], value=bool(selected_user[col_name]))
            col_name = 'note'
            note = st.text_area(COL_LABELS[TABLE_H7_USER][col_name], value=selected_user[col_name])

        if st.button("Update User"):
            update_user(username, email, int(is_admin), int(is_active), profile, note)
            st.success("User updated successfully")
            st.rerun()

# Function to view all data
def query_all_notes(username):
    sql_stmt = f'''
        SELECT * FROM {TABLE_H7_NOTE} where created_by = '{username}' order by updated_at desc;
    '''
    return run_sql(sql_stmt)

def query_user_keys(key_data):
    """
    Input: key_data (dict) - 
        {
            "table_name": ... ,
            "user_key_1": ... ,
            ...... ,
            "created_by"
        }
    Returns: 
        id - None (when no row matched) else row_id
    """
    table_name = key_data.get("table_name", "")
    if not table_name:
        return None
    
    if table_name not in USER_KEY_COLS: 
        return None

    created_by = st.session_state['username']

    if table_name == TABLE_H7_USER:
        email = key_data.get("email", "")
        username = key_data.get("username", "")
        sql_stmt = f"""
            select id from {table_name}
            where created_by='{created_by}'
                and email='{email}'
                and username='{username}'
            ;
        """
    elif table_name == TABLE_H7_TASK:
        task_name = key_data.get("task_name", "")
        task_type = key_data.get("task_type", "")
        sql_stmt = f"""
            select id from {table_name}
            where created_by='{created_by}'
                and task_name='{task_name}'
                and task_type='{task_type}'
            ;
        """
    elif table_name == TABLE_H7_NOTE:
        note_name = key_data.get("note_name", "")
        note_type = key_data.get("note_type", "")
        sql_stmt = f"""
            select id from {table_name}
            where created_by='{created_by}'
                and note_name='{note_name}'
                and note_type='{note_type}'
            ;
        """
    with DBConn() as conn:
        df = pd.read_sql(sql_stmt, conn)
        if df is None or df.empty or df.shape[0] < 1:
            return None
        
        return df["id"].to_list()[0]


def add_note(note_name, url, note_type, note, tags, created_at, username, updated_at):
    # query if record exists
    table_name = TABLE_H7_NOTE
    key_data = dict(table_name=table_name, note_name=note_name, url=url, note_type=note_type)
    id = query_user_keys(key_data)
    if id:
        msg = f"""Record already exists:\n
            id={id}, note_name='{note_name}', url='{url}', note_type='{note_type}'       
        """
        return msg
    
    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
            INSERT INTO {table_name} (note_name, url, note_type, note, tags, created_by, created_at, updated_by, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (note_name, url, note_type, note, tags, username, created_at, username, updated_at))
        msg = f"Record added: note_name='{note_name}', note_type='{note_type}'"
    except Exception as e:
        msg = f"[DB-ERROR] {str(e)}"

    return msg

def delete_note_by_id(note_id, username):
    try:
        sql_stmt = f'''
            DELETE FROM {TABLE_H7_NOTE} where id={note_id} and created_by = '{username}';
        '''
        return run_sql(sql_stmt)
    except Exception as e:
        print(f"[DB-ERROR] {str(e)}")

def edit_note_by_id(new_note_name, new_url, new_note_type, new_note, new_tags, new_updated_by, new_updated_at, note_id, username):
    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
                UPDATE {TABLE_H7_NOTE} 
                SET note_name=?, url=?, note_type=?, note=?, tags=?, updated_by=?, updated_at=?
                WHERE id=? and created_by=?
            ''', (new_note_name, new_url, new_note_type, new_note, new_tags, new_updated_by, new_updated_at
                , note_id, username)
            )
            return c.fetchall()
    except Exception as e:
        print(f"[DB-ERROR] {str(e)}")

def handle_note_form(df, username, key_name):
    # display note list
    grid_resp = _display_df_grid(df, key_name=key_name)
    selected_rows = grid_resp['selected_rows']

    # streamlit-aggrid==1.0.5
    selected_row = None if selected_rows is None or len(selected_rows) < 1 else selected_rows.to_dict(orient='records')[0]
    # display task form
    if selected_row is None:
        v_id = v_note_name = v_url = v_note = v_note_type = v_tags = ""
        v_created_by = v_updated_by = username
        v_created_at = v_updated_at = date.today()
    else:
        v_id = selected_row.get("id") 
        v_note_name = selected_row.get("note_name")
        v_url = selected_row.get("url")
        v_note = selected_row.get("note")
        v_note_type = selected_row.get("note_type")
        v_tags = selected_row.get("tags")
        v_created_by = selected_row.get("created_by")
        v_updated_by = selected_row.get("updated_by")
        v_created_at = datetime.strptime(selected_row.get("created_at"), "%Y-%m-%d")
        v_updated_at = datetime.strptime(selected_row.get("updated_at"), "%Y-%m-%d")

    col1, col2, col3 = st.columns([3,3,2])
    with col1:
        note_name = st.text_input(COL_LABELS[TABLE_H7_NOTE]['note_name'], value=v_note_name)
        url = st.text_area(COL_LABELS[TABLE_H7_NOTE]['url'],  value=v_url)
        note_type = st.selectbox(COL_LABELS[TABLE_H7_NOTE]['note_type'], LIST_NOTE_TYPE, index=LIST_NOTE_TYPE.index(""))

    with col2:
        note = st.text_area(COL_LABELS[TABLE_H7_NOTE]['note'],  value=v_note)
        tags = st.text_area(COL_LABELS[TABLE_H7_NOTE]['tags'],  value=v_tags)

    with col3:
        id = st.text_input(COL_LABELS[TABLE_H7_NOTE]['id'],  value=v_id, disabled=True)
        # created_by = st.text_input(COL_LABELS[TABLE_H7_NOTE]['created_by'],  value=v_created_by)
        created_at = st.date_input(COL_LABELS[TABLE_H7_NOTE]['created_at'],  value=v_created_at)
        updated_by = st.text_input(COL_LABELS[TABLE_H7_NOTE]['updated_by'],  value=v_updated_by)
        updated_at = st.date_input(COL_LABELS[TABLE_H7_NOTE]['updated_at'],  value=v_updated_at)

    if selected_row is None or not v_id: 
        c_1, _, _ = st.columns([3,3,2])
        with c_1:
            btn_add = st.button("Add Note")

        if btn_add:
            msg = add_note(note_name, url, note_type, note, tags, created_at, username, updated_at)
            if "Record added" in msg:
                st.success(msg)
            elif "Record already exists" in msg:
                st.warning(msg)
            else:
                st.error(msg)

    else:
        delete_flag = False
        c_1, _, c_2 = st.columns([3,3,2])
        with c_1:
            btn = st.button("Update Note")
        with c_2:
            delete_flag = st.checkbox("Delete?", value=False)

        if btn:
            if delete_flag:
                delete_note_by_id(v_id, username)
                st.success(f"Note Deleted: {v_id}")
            else:
                edit_note_by_id(note_name, url, note_type, note, tags, updated_by, updated_at, v_id, username)
                st.success(f"Note Updated: {v_id}")



# Function to add data
def add_task(task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, created_by, created_at, updated_by, updated_at):
    # query if record exists
    table_name = TABLE_H7_TASK
    key_data = dict(table_name=table_name, task_name=task_name, task_type=task_type)
    id = query_user_keys(key_data)
    if id:
        msg = f"""Record already exists:\n
            id={id}, task_name='{task_name}', task_type='{task_type}'       
        """
        return msg

    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
            INSERT INTO {table_name} (task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, created_by, created_at, updated_by, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (task_name, description, task_group, is_urgent, is_important, status, pct_completed, due_date, task_type, note, created_by, created_at, updated_by, updated_at))
        msg = f"Record added: task_name='{task_name}', task_type='{task_type}'"
    except Exception as e:
        msg = f"[DB-ERROR] {str(e)}"

    return msg


# Function to view all data
def query_all_tasks(username):
    sql_stmt = f'''
        SELECT * FROM {TABLE_H7_TASK} where created_by = '{username}' order by updated_at desc;
    '''
    return run_sql(sql_stmt)

def query_tasks_by_ids(username, ids=[]):
    df = None 
    if not ids:
        return df 
    
    if ids:
        ids_str = ",".join([str(id) for id in ids])
        ids_clase = f" id in ({ids_str}) "

        sql_stmt = f'''
            SELECT * FROM {TABLE_H7_TASK} 
            where created_by = '{username}' 
                and {ids_clase}
            order by updated_at desc;
        '''
        return run_sql(sql_stmt)

# Function to view all task names
def query_all_task_names(username):
    sql_stmt = f'''
        SELECT task_name, id FROM {TABLE_H7_TASK} where created_by = '{username}' order by task_name;
    '''
    return run_sql(sql_stmt)

# Function to get task by name
def get_task_by_name(task_name, username):
    # TODO - escape single quote in task_name
    sql_stmt = f'''
        SELECT * FROM {TABLE_H7_TASK} where task_name='{task_name}' and created_by = '{username}' order by task_name;
    '''
    return run_sql(sql_stmt)

def get_task_by_id(task_id, username):
    sql_stmt = f'''
        SELECT * FROM {TABLE_H7_TASK} where id={task_id} and created_by = '{username}' order by task_name;
    '''
    return run_sql(sql_stmt)

# Function to get task by status
def get_task_by_status(status, username):
    sql_stmt = f'''
        SELECT * FROM {TABLE_H7_TASK} where status={status} and created_by = '{username}' order by task_name;
    '''
    return run_sql(sql_stmt)

# Function to edit task data
# def edit_task(new_task_name, new_description, new_task_group, new_is_urgent, new_is_important, new_status, new_pct_completed, new_due_date, new_task_type, new_note, new_updated_by, new_updated_at, task_name, username):
#     with DBConn() as conn:
#         c = conn.cursor()
#         c.execute(f'''
#             UPDATE {TABLE_H7_TASK} 
#             SET task_name=?, description=?, task_group=?, is_urgent=?, is_important=?, status=?, pct_completed=?, due_date=?, task_type=?, note=?, updated_by=?, updated_at=?
#             WHERE task_name=? and created_by=?
#         ''', (new_task_name, new_description, new_task_group, new_is_urgent, new_is_important, new_status, new_pct_completed, new_due_date, new_task_type, new_note, new_updated_by, new_updated_at
#             , task_name, username)
#         )
#         return c.fetchall()


def edit_task_by_id(new_task_name, new_description, new_task_group, new_is_urgent, new_is_important, new_status, new_pct_completed, new_due_date, new_task_type, new_note, new_updated_by, new_updated_at, id, username):
    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f'''
                UPDATE {TABLE_H7_TASK} 
                SET task_name=?, description=?, task_group=?, is_urgent=?, is_important=?, status=?, pct_completed=?, due_date=?, task_type=?, note=?, updated_by=?, updated_at=?
                WHERE id=? and created_by=?
            ''', (new_task_name, new_description, new_task_group, new_is_urgent, new_is_important, new_status, new_pct_completed, new_due_date, new_task_type, new_note, new_updated_by, new_updated_at
                , id, username)
            )
            return c.fetchall()
    except Exception as e:
        print(f"[DB-ERROR] {str(e)}")

def parse_task_id(task_string):
	# Regular expression pattern
	pattern = r'^(.*?)\s*\[(\d+)\]$'
	
	# Try to match the pattern
	match = re.match(pattern, task_string)
	
	if match:
		# If there's a match, extract the groups
		task_name = match.group(1).strip()
		task_id = int(match.group(2))
		return task_name, task_id
	else:
		# If no match, return None for both values
		return None, None

# Function to delete data
# def delete_task(task_name, username):
#     sql_stmt = f'''
#         DELETE FROM {TABLE_H7_TASK} where task_name='{task_name}' and created_by = '{username}';
#     '''
#     return run_sql(sql_stmt)

def delete_task_by_id(task_id, username):
    try:
        sql_stmt = f'''
            DELETE FROM {TABLE_H7_TASK} where id={task_id} and created_by = '{username}';
        '''
        return run_sql(sql_stmt)
    except Exception as e:
        print(f"[DB-ERROR] {str(e)}")


# Function to hash password
def hash_password(password):
    return hashlib.sha256(str.encode(password)).hexdigest()


# Function to verify user
def verify_user(email, password):
    hashed_password = hash_password(password)
    try:
        with DBConn() as conn:
            c = conn.cursor()
            c.execute(f"SELECT * FROM {TABLE_H7_USER} WHERE email = ? AND password = ?", (email, hashed_password))
            user = c.fetchone()
            return user
    except Exception as e:
        print(f"[DB-ERROR] {str(e)}")

# Function to check if email exists
def email_exists(email):
    with DBConn() as conn:
        c = conn.cursor()
        c.execute(f"SELECT * FROM {TABLE_H7_USER} WHERE email = ?", (email,))
        user = c.fetchone()
        return user is not None

# Login page
def login_page():
    st.subheader("Login")
    email = st.text_input("Email")
    password = st.text_input("Password", type="password")
    if st.button("Login"):
        user = verify_user(email, password)
        st.write(user)
        if user:
            st.session_state['logged_in'] = True
            st.session_state['user_id'] = user[0]
            user_name = user[3]
            st.session_state['username'] = user_name
            st.session_state['is_admin'] = bool(user[4])
            st.success(f"Logged in as {user_name}, user_id={user[0]}")
            st.rerun()
        else:
            st.error("Incorrect email or password or account is inactive")

# Registration page
def registration_page():
    st.subheader("Register")
    
    email = st.text_input("Email")
    username = st.text_input("Username")
    password = st.text_input("Password", type="password")
    confirm_password = st.text_input("Confirm Password", type="password")
    
    if st.button("Register"):      
        if password != confirm_password:
            st.error("Passwords do not match")
        elif email_exists(email):
            st.error("Email already exists")
        else:
            try:
                add_user(email, password, username)
                st.success("Registration successful. Please login.")
                # check_database_state()  # Check the database state after registration
            except Exception as e:
                st.error(f"An error occurred during registration: {str(e)}")
                # check_database_state()  # Check the database state even if there's an error

# Main app logic
def main():
    st.sidebar.subheader("7 Habits Task Manager")

    DEBUG_FLAG = False
    if DEBUG_FLAG:
        # Display debug information
        user_count = 0
        sql_stmt = f"SELECT COUNT(*) FROM {TABLE_H7_USER}"
        df = run_sql(sql_stmt)
        if df is not None and not df.empty:
            user_count = df.iloc[0,0]
            st.write(f"[DEBUG] Total users: {user_count}")
        
        if user_count > 0:
            sql_stmt = f"SELECT COUNT(*) FROM {TABLE_H7_USER} WHERE is_admin = 1"
            df = run_sql(sql_stmt)
            if df is not None and not df.empty:
                admin_count = df.iloc[0,0]
                st.write(f"[DEBUG] Admin users: {admin_count}")

    # Initialize session state
    if 'logged_in' not in st.session_state:
        st.session_state['logged_in'] = False

    # Sidebar for login/logout
    if st.session_state['logged_in']:
        st.sidebar.success(f"Logged in as: {st.session_state['username']}")
        if st.sidebar.button("Logout"):
            init_session_state()
            st.rerun()
    else:
        auth_option = st.sidebar.radio("Choose an option", ["Login", "Register"])
        if auth_option == "Login":
            login_page()
        else:
            registration_page()

    # Only show the app if logged in
    if not st.session_state['logged_in']:
        return
    
    username = st.session_state['username']
    is_admin = st.session_state['is_admin']


    
    menu = [
        PAGE_HOME, 
        PAGE_7_HABITS_TASK, 
        PAGE_MANAGE_TASK,
        PAGE_MANAGE_NOTE, 
        PAGE_EDIT_USER,
    ]

    if is_admin:
        menu_admin = [
            "Add User", 
            "Manage Users", 
            "Admin Tasks"
        ] 
        menu.extend(menu_admin)

    choice = st.sidebar.selectbox("Menu", menu)

    if choice == "Home":
        st.subheader("Home")
        st.write("Welcome to the 7 Habits Task Manager. Use the sidebar to navigate through the app.")
        st.write("[Learn more about the 7 Habits of Highly Effective People](https://en.wikipedia.org/wiki/The_7_Habits_of_Highly_Effective_People)")

    elif choice == PAGE_MANAGE_NOTE:
        st.subheader(PAGE_MANAGE_NOTE)
        df = query_all_notes(username)
        handle_note_form(df, username, key_name="note_df_all")

    elif choice == PAGE_MANAGE_TASK:
        st.subheader(PAGE_MANAGE_TASK)
        df = query_all_tasks(username)
        handle_task_form(df, username, key_name="task_df_all")

    elif choice == PAGE_7_HABITS_TASK:
        st.subheader("7 Habits View")

        # Filters
        f_1, f_2 = st.columns(2)
        with f_1:
            selected_task_groups = st.multiselect("Filter by Task Group", LIST_TASK_GROUP, default=["Personal"])
        with f_2:
            selected_statuses = st.multiselect("Filter by Status", LIST_TASK_STATUS, default=["ToDo", "Doing"])

        # Fetch all tasks
        df_all = query_all_tasks(username)
        # Apply filters
        df = df_all[(df_all['task_group'].isin(selected_task_groups)) & (df_all['status'].isin(selected_statuses))]
        selected_cols = ["task_name", "status", "task_group", "description", "id"]

        selected_ids = []
        # Display quadrants in a 2x2 grid layout
        row1_col1, row1_col2 = st.columns(2)
        with row1_col1:
            st.markdown("##### Un-Important/Urgent (ii)")
            df_2 = df[(df['is_important'] == 'N') & (df['is_urgent'] == 'Y')][selected_cols]
            grid_resp_2 = _display_df_grid(df_2, key_name="df_2", page_size=PAGE_SIZE, grid_height=GRID_HEIGHT)
            selected_rows_2 = grid_resp_2['selected_rows']
            if selected_rows_2 is not None and not selected_rows_2.empty:
                selected_ids += selected_rows_2["id"].to_list()

        with row1_col2:
            st.markdown("##### Important/Urgent (i)")
            df_1 = df[(df['is_important'] == 'Y') & (df['is_urgent'] == 'Y')][selected_cols]
            grid_resp_1 = _display_df_grid(df_1, key_name="df_1", page_size=PAGE_SIZE, grid_height=GRID_HEIGHT)
            selected_rows_1 = grid_resp_1['selected_rows']
            if selected_rows_1 is not None and not selected_rows_1.empty:
                selected_ids += selected_rows_1["id"].to_list()

        row2_col1, row2_col2 = st.columns(2)
        with row2_col1:
            st.markdown("##### Un-Important/Un-Urgent (iii)")
            df_3 = df[(df['is_important'] == 'N') & (df['is_urgent'] == 'N')][selected_cols]
            grid_resp_3 = _display_df_grid(df_3, key_name="df_3", page_size=PAGE_SIZE, grid_height=GRID_HEIGHT)
            selected_rows_3 = grid_resp_3['selected_rows']
            if selected_rows_3 is not None and not selected_rows_3.empty:
                selected_ids += selected_rows_3["id"].to_list()

        with row2_col2:
            st.markdown("##### Important/Un-Urgent (iv)")
            df_4 = df[(df['is_important'] == 'Y') & (df['is_urgent'] == 'N')][selected_cols]
            grid_resp_4 = _display_df_grid(df_4, key_name="df_4", page_size=PAGE_SIZE, grid_height=GRID_HEIGHT)
            selected_rows_4 = grid_resp_4['selected_rows']
            if selected_rows_4 is not None and not selected_rows_4.empty:
                selected_ids += selected_rows_4["id"].to_list()

        if selected_ids:
            # st.write(selected_ids)
            df_selected = query_tasks_by_ids(username, ids=selected_ids)
            if df_selected is not None and not df_selected.empty:
                # st.dataframe(df_selected)
                handle_task_form(df_selected, username, key_name="task_df_selected")


    elif choice == PAGE_EDIT_USER:
        edit_user_page(username, is_admin)

    elif choice == "Add User" and is_admin:
        new_user_page()

    elif choice == "Manage Users" and is_admin:
        manage_users_page()

    elif choice == "Admin Tasks" and is_admin:
        admin_tasks_page()

def admin_tasks_page():
    file_list = sorted(glob("tests/*.sql"))
    selected_script_path = st.selectbox("Select script", file_list)
    sql_stmt = open(selected_script_path).read()
    st.text_area("Review", value=sql_stmt, disabled=True)
    if st.button(f"Run Script"):
        run_sql(sql_stmt)

def clear_database():
    sql_stmt = f""" 
        DROP TABLE IF EXISTS {TABLE_H7_USER};
        DROP TABLE IF EXISTS {TABLE_H7_TASK};
    """
    run_sql(sql_stmt)
    st.write("[DEBUG] Database cleared")

if __name__ == '__main__':
    create_tables()
    main()